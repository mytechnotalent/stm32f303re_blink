embassy_hal_internal :: peripherals_definition ! (ADC1 , ADC2 , ADC3 , ADC3_COMMON , ADC4 , ADC_COMMON , CAN , CRC , DAC1 , DBGMCU , DMA1 , DMA2 , FLASH , PA0 , PA1 , PA2 , PA3 , PA4 , PA5 , PA6 , PA7 , PA8 , PA9 , PA10 , PA11 , PA12 , PA13 , PA14 , PA15 , PB0 , PB1 , PB2 , PB3 , PB4 , PB5 , PB6 , PB7 , PB8 , PB9 , PB10 , PB11 , PB12 , PB13 , PB14 , PB15 , PC0 , PC1 , PC2 , PC3 , PC4 , PC5 , PC6 , PC7 , PC8 , PC9 , PC10 , PC11 , PC12 , PC13 , PC14 , PC15 , PD0 , PD1 , PD2 , PD3 , PD4 , PD5 , PD6 , PD7 , PD8 , PD9 , PD10 , PD11 , PD12 , PD13 , PD14 , PD15 , PE0 , PE1 , PE2 , PE3 , PE4 , PE5 , PE6 , PE7 , PE8 , PE9 , PE10 , PE11 , PE12 , PE13 , PE14 , PE15 , PF0 , PF1 , PF2 , PF3 , PF4 , PF5 , PF6 , PF7 , PF8 , PF9 , PF10 , PF11 , PF12 , PF13 , PF14 , PF15 , PG0 , PG1 , PG2 , PG3 , PG4 , PG5 , PG6 , PG7 , PG8 , PG9 , PG10 , PG11 , PG12 , PG13 , PG14 , PG15 , PH0 , PH1 , PH2 , PH3 , PH4 , PH5 , PH6 , PH7 , PH8 , PH9 , PH10 , PH11 , PH12 , PH13 , PH14 , PH15 , I2C1 , I2C2 , I2C3 , IWDG , OPAMP1 , OPAMP2 , OPAMP3 , OPAMP4 , PWR , MCO , RCC , RTC , SPI1 , SPI2 , SPI3 , SYSCFG , TIM1 , TIM15 , TIM16 , TIM17 , TIM2 , TIM3 , TIM4 , TIM6 , TIM7 , TIM8 , TSC , UART4 , UART5 , UID , USART1 , USART2 , USART3 , USB , USBRAM , VREFINTCAL , WWDG , EXTI0 , EXTI1 , EXTI2 , EXTI3 , EXTI4 , EXTI5 , EXTI6 , EXTI7 , EXTI8 , EXTI9 , EXTI10 , EXTI11 , EXTI12 , EXTI13 , EXTI14 , EXTI15 , DMA1_CH1 , DMA1_CH2 , DMA1_CH3 , DMA1_CH4 , DMA1_CH5 , DMA1_CH6 , DMA1_CH7 , DMA2_CH1 , DMA2_CH2 , DMA2_CH3 , DMA2_CH4 , DMA2_CH5) ; embassy_hal_internal :: peripherals_struct ! (ADC1 , ADC2 , ADC3 , ADC3_COMMON , ADC4 , ADC_COMMON , CAN , CRC , DAC1 , DBGMCU , DMA1 , DMA2 , FLASH , PA0 , PA1 , PA2 , PA3 , PA4 , PA5 , PA6 , PA7 , PA8 , PA9 , PA10 , PA11 , PA12 , PA13 , PA14 , PA15 , PB0 , PB1 , PB2 , PB3 , PB4 , PB5 , PB6 , PB7 , PB8 , PB9 , PB10 , PB11 , PB12 , PB13 , PB14 , PB15 , PC0 , PC1 , PC2 , PC3 , PC4 , PC5 , PC6 , PC7 , PC8 , PC9 , PC10 , PC11 , PC12 , PC13 , PC14 , PC15 , PD0 , PD1 , PD2 , PD3 , PD4 , PD5 , PD6 , PD7 , PD8 , PD9 , PD10 , PD11 , PD12 , PD13 , PD14 , PD15 , PE0 , PE1 , PE2 , PE3 , PE4 , PE5 , PE6 , PE7 , PE8 , PE9 , PE10 , PE11 , PE12 , PE13 , PE14 , PE15 , PF0 , PF1 , PF2 , PF3 , PF4 , PF5 , PF6 , PF7 , PF8 , PF9 , PF10 , PF11 , PF12 , PF13 , PF14 , PF15 , PG0 , PG1 , PG2 , PG3 , PG4 , PG5 , PG6 , PG7 , PG8 , PG9 , PG10 , PG11 , PG12 , PG13 , PG14 , PG15 , PH0 , PH1 , PH2 , PH3 , PH4 , PH5 , PH6 , PH7 , PH8 , PH9 , PH10 , PH11 , PH12 , PH13 , PH14 , PH15 , I2C1 , I2C2 , I2C3 , IWDG , OPAMP1 , OPAMP2 , OPAMP3 , OPAMP4 , PWR , MCO , RCC , RTC , SPI1 , SPI2 , SPI3 , SYSCFG , TIM1 , TIM15 , TIM16 , TIM17 , TIM3 , TIM4 , TIM6 , TIM7 , TIM8 , TSC , UART4 , UART5 , UID , USART1 , USART2 , USART3 , USB , USBRAM , VREFINTCAL , WWDG , EXTI0 , EXTI1 , EXTI2 , EXTI3 , EXTI4 , EXTI5 , EXTI6 , EXTI7 , EXTI8 , EXTI9 , EXTI10 , EXTI11 , EXTI12 , EXTI13 , EXTI14 , EXTI15 , DMA1_CH1 , DMA1_CH2 , DMA1_CH3 , DMA1_CH4 , DMA1_CH5 , DMA1_CH6 , DMA1_CH7 , DMA2_CH1 , DMA2_CH2 , DMA2_CH3 , DMA2_CH4 , DMA2_CH5) ; embassy_hal_internal :: interrupt_mod ! (WWDG , PVD , TAMP_STAMP , RTC_WKUP , FLASH , RCC , EXTI0 , EXTI1 , EXTI2_TSC , EXTI3 , EXTI4 , DMA1_CHANNEL1 , DMA1_CHANNEL2 , DMA1_CHANNEL3 , DMA1_CHANNEL4 , DMA1_CHANNEL5 , DMA1_CHANNEL6 , DMA1_CHANNEL7 , ADC1_2 , USB_HP_CAN_TX , USB_LP_CAN_RX0 , CAN_RX1 , CAN_SCE , EXTI9_5 , TIM1_BRK_TIM15 , TIM1_UP_TIM16 , TIM1_TRG_COM_TIM17 , TIM1_CC , TIM2 , TIM3 , TIM4 , I2C1_EV , I2C1_ER , I2C2_EV , I2C2_ER , SPI1 , SPI2 , USART1 , USART2 , USART3 , EXTI15_10 , RTC_ALARM , USBWAKEUP , TIM8_BRK , TIM8_UP , TIM8_TRG_COM , TIM8_CC , ADC3 , FMC , SPI3 , UART4 , UART5 , TIM6_DAC , TIM7 , DMA2_CHANNEL1 , DMA2_CHANNEL2 , DMA2_CHANNEL3 , DMA2_CHANNEL4 , DMA2_CHANNEL5 , ADC4 , COMP1_2_3 , COMP4_5_6 , COMP7 , I2C3_EV , I2C3_ER , USB_HP , USB_LP , USBWAKEUP_RMP , TIM20_BRK , TIM20_UP , TIM20_TRG_COM , TIM20_CC , FPU , SPI4 ,) ; pub const MAX_ERASE_SIZE : usize = 2048u32 as usize ; pub mod flash_regions { pub const BANK1_REGION : crate :: flash :: FlashRegion = crate :: flash :: FlashRegion { bank : crate :: flash :: FlashBank :: Bank1 , base : 134217728u32 , size : 524288u32 , erase_size : 2048u32 , write_size : 8u32 , erase_value : 255u8 , _ensure_internal : () , } ; # [cfg (flash)] pub struct Bank1Region < 'd , MODE = crate :: flash :: Async > (pub & 'static crate :: flash :: FlashRegion , pub (crate) embassy_hal_internal :: PeripheralRef < 'd , crate :: peripherals :: FLASH > , pub (crate) core :: marker :: PhantomData < MODE >) ; # [cfg (flash)] pub struct FlashLayout < 'd , MODE = crate :: flash :: Async > { pub bank1_region : Bank1Region < 'd , MODE > , _mode : core :: marker :: PhantomData < MODE > , } # [cfg (flash)] impl < 'd , MODE > FlashLayout < 'd , MODE > { pub (crate) fn new (p : embassy_hal_internal :: PeripheralRef < 'd , crate :: peripherals :: FLASH >) -> Self { Self { bank1_region : Bank1Region (& BANK1_REGION , unsafe { p . clone_unchecked () } , core :: marker :: PhantomData) , _mode : core :: marker :: PhantomData , } } } pub const FLASH_REGIONS : [& crate :: flash :: FlashRegion ; 1usize] = [& BANK1_REGION] ; } # [cfg (feature = "rt")] # [crate :: interrupt] unsafe fn DMA1_CHANNEL1 () { < crate :: peripherals :: DMA1_CH1 as crate :: dma :: bdma :: sealed :: Channel > :: on_irq () ; } # [cfg (feature = "rt")] # [crate :: interrupt] unsafe fn DMA1_CHANNEL2 () { < crate :: peripherals :: DMA1_CH2 as crate :: dma :: bdma :: sealed :: Channel > :: on_irq () ; } # [cfg (feature = "rt")] # [crate :: interrupt] unsafe fn DMA1_CHANNEL3 () { < crate :: peripherals :: DMA1_CH3 as crate :: dma :: bdma :: sealed :: Channel > :: on_irq () ; } # [cfg (feature = "rt")] # [crate :: interrupt] unsafe fn DMA1_CHANNEL4 () { < crate :: peripherals :: DMA1_CH4 as crate :: dma :: bdma :: sealed :: Channel > :: on_irq () ; } # [cfg (feature = "rt")] # [crate :: interrupt] unsafe fn DMA1_CHANNEL5 () { < crate :: peripherals :: DMA1_CH5 as crate :: dma :: bdma :: sealed :: Channel > :: on_irq () ; } # [cfg (feature = "rt")] # [crate :: interrupt] unsafe fn DMA1_CHANNEL6 () { < crate :: peripherals :: DMA1_CH6 as crate :: dma :: bdma :: sealed :: Channel > :: on_irq () ; } # [cfg (feature = "rt")] # [crate :: interrupt] unsafe fn DMA1_CHANNEL7 () { < crate :: peripherals :: DMA1_CH7 as crate :: dma :: bdma :: sealed :: Channel > :: on_irq () ; } # [cfg (feature = "rt")] # [crate :: interrupt] unsafe fn DMA2_CHANNEL1 () { < crate :: peripherals :: DMA2_CH1 as crate :: dma :: bdma :: sealed :: Channel > :: on_irq () ; } # [cfg (feature = "rt")] # [crate :: interrupt] unsafe fn DMA2_CHANNEL2 () { < crate :: peripherals :: DMA2_CH2 as crate :: dma :: bdma :: sealed :: Channel > :: on_irq () ; } # [cfg (feature = "rt")] # [crate :: interrupt] unsafe fn DMA2_CHANNEL3 () { < crate :: peripherals :: DMA2_CH3 as crate :: dma :: bdma :: sealed :: Channel > :: on_irq () ; } # [cfg (feature = "rt")] # [crate :: interrupt] unsafe fn DMA2_CHANNEL4 () { < crate :: peripherals :: DMA2_CH4 as crate :: dma :: bdma :: sealed :: Channel > :: on_irq () ; } # [cfg (feature = "rt")] # [crate :: interrupt] unsafe fn DMA2_CHANNEL5 () { < crate :: peripherals :: DMA2_CH5 as crate :: dma :: bdma :: sealed :: Channel > :: on_irq () ; } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: ADC1 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . hclk1 } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { unsafe { refcount_statics :: AHBENR_ADC12EN += 1 } ; if unsafe { refcount_statics :: AHBENR_ADC12EN } > 1 { return ; } # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . ahbenr () . modify (| w | w . set_adc12en (true)) ; crate :: pac :: RCC . ahbrstr () . modify (| w | w . set_adc12rst (true)) ; crate :: pac :: RCC . ahbrstr () . modify (| w | w . set_adc12rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { unsafe { refcount_statics :: AHBENR_ADC12EN -= 1 } ; if unsafe { refcount_statics :: AHBENR_ADC12EN } > 0 { return ; } crate :: pac :: RCC . ahbenr () . modify (| w | w . set_adc12en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: ADC1 { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: ADC2 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . hclk1 } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { unsafe { refcount_statics :: AHBENR_ADC12EN += 1 } ; if unsafe { refcount_statics :: AHBENR_ADC12EN } > 1 { return ; } # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . ahbenr () . modify (| w | w . set_adc12en (true)) ; crate :: pac :: RCC . ahbrstr () . modify (| w | w . set_adc12rst (true)) ; crate :: pac :: RCC . ahbrstr () . modify (| w | w . set_adc12rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { unsafe { refcount_statics :: AHBENR_ADC12EN -= 1 } ; if unsafe { refcount_statics :: AHBENR_ADC12EN } > 0 { return ; } crate :: pac :: RCC . ahbenr () . modify (| w | w . set_adc12en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: ADC2 { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: ADC3 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . hclk1 } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { unsafe { refcount_statics :: AHBENR_ADC34EN += 1 } ; if unsafe { refcount_statics :: AHBENR_ADC34EN } > 1 { return ; } # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . ahbenr () . modify (| w | w . set_adc34en (true)) ; crate :: pac :: RCC . ahbrstr () . modify (| w | w . set_adc34rst (true)) ; crate :: pac :: RCC . ahbrstr () . modify (| w | w . set_adc34rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { unsafe { refcount_statics :: AHBENR_ADC34EN -= 1 } ; if unsafe { refcount_statics :: AHBENR_ADC34EN } > 0 { return ; } crate :: pac :: RCC . ahbenr () . modify (| w | w . set_adc34en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: ADC3 { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: ADC4 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . hclk1 } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { unsafe { refcount_statics :: AHBENR_ADC34EN += 1 } ; if unsafe { refcount_statics :: AHBENR_ADC34EN } > 1 { return ; } # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . ahbenr () . modify (| w | w . set_adc34en (true)) ; crate :: pac :: RCC . ahbrstr () . modify (| w | w . set_adc34rst (true)) ; crate :: pac :: RCC . ahbrstr () . modify (| w | w . set_adc34rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { unsafe { refcount_statics :: AHBENR_ADC34EN -= 1 } ; if unsafe { refcount_statics :: AHBENR_ADC34EN } > 0 { return ; } crate :: pac :: RCC . ahbenr () . modify (| w | w . set_adc34en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: ADC4 { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: CAN { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1 } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_canen (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_canrst (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_canrst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb1enr () . modify (| w | w . set_canen (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: CAN { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: CRC { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . hclk1 } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . ahbenr () . modify (| w | w . set_crcen (true)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . ahbenr () . modify (| w | w . set_crcen (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: CRC { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: DAC1 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1 } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_dacen (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_dacrst (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_dacrst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb1enr () . modify (| w | w . set_dacen (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: DAC1 { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: DBGMCU { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk2 } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb2enr () . modify (| w | w . set_dbgmcuen (true)) ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_dbgmcurst (true)) ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_dbgmcurst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb2enr () . modify (| w | w . set_dbgmcuen (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: DBGMCU { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: DMA1 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . hclk1 } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . ahbenr () . modify (| w | w . set_dma1en (true)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . ahbenr () . modify (| w | w . set_dma1en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: DMA1 { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: DMA2 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . hclk1 } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . ahbenr () . modify (| w | w . set_dma2en (true)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . ahbenr () . modify (| w | w . set_dma2en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: DMA2 { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: FLASH { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . hclk1 } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . ahbenr () . modify (| w | w . set_flashen (true)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . ahbenr () . modify (| w | w . set_flashen (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: FLASH { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: I2C1 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1 } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_i2c1en (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_i2c1rst (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_i2c1rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb1enr () . modify (| w | w . set_i2c1en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: I2C1 { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: I2C2 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1 } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_i2c2en (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_i2c2rst (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_i2c2rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb1enr () . modify (| w | w . set_i2c2en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: I2C2 { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: I2C3 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1 } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_i2c3en (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_i2c3rst (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_i2c3rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb1enr () . modify (| w | w . set_i2c3en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: I2C3 { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: PWR { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1 } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_pwren (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_pwrrst (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_pwrrst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb1enr () . modify (| w | w . set_pwren (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: PWR { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: SPI1 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk2 } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb2enr () . modify (| w | w . set_spi1en (true)) ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_spi1rst (true)) ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_spi1rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb2enr () . modify (| w | w . set_spi1en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: SPI1 { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: SPI2 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1 } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_spi2en (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_spi2rst (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_spi2rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb1enr () . modify (| w | w . set_spi2en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: SPI2 { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: SPI3 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1 } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_spi3en (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_spi3rst (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_spi3rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb1enr () . modify (| w | w . set_spi3en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: SPI3 { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: SYSCFG { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk2 } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb2enr () . modify (| w | w . set_syscfgen (true)) ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_syscfgrst (true)) ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_syscfgrst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb2enr () . modify (| w | w . set_syscfgen (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: SYSCFG { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: TIM1 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk2_tim } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb2enr () . modify (| w | w . set_tim1en (true)) ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_tim1rst (true)) ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_tim1rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb2enr () . modify (| w | w . set_tim1en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: TIM1 { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: TIM15 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk2_tim } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb2enr () . modify (| w | w . set_tim15en (true)) ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_tim15rst (true)) ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_tim15rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb2enr () . modify (| w | w . set_tim15en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: TIM15 { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: TIM16 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk2_tim } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb2enr () . modify (| w | w . set_tim16en (true)) ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_tim16rst (true)) ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_tim16rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb2enr () . modify (| w | w . set_tim16en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: TIM16 { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: TIM17 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk2_tim } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb2enr () . modify (| w | w . set_tim17en (true)) ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_tim17rst (true)) ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_tim17rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb2enr () . modify (| w | w . set_tim17en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: TIM17 { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: TIM2 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1_tim } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_tim2en (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_tim2rst (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_tim2rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb1enr () . modify (| w | w . set_tim2en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: TIM2 { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: TIM3 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1_tim } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_tim3en (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_tim3rst (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_tim3rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb1enr () . modify (| w | w . set_tim3en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: TIM3 { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: TIM4 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1_tim } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_tim4en (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_tim4rst (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_tim4rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb1enr () . modify (| w | w . set_tim4en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: TIM4 { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: TIM6 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1_tim } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_tim6en (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_tim6rst (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_tim6rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb1enr () . modify (| w | w . set_tim6en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: TIM6 { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: TIM7 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1_tim } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_tim7en (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_tim7rst (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_tim7rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb1enr () . modify (| w | w . set_tim7en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: TIM7 { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: TIM8 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk2_tim } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb2enr () . modify (| w | w . set_tim8en (true)) ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_tim8rst (true)) ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_tim8rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb2enr () . modify (| w | w . set_tim8en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: TIM8 { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: TSC { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . hclk1 } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . ahbenr () . modify (| w | w . set_tscen (true)) ; crate :: pac :: RCC . ahbrstr () . modify (| w | w . set_tscrst (true)) ; crate :: pac :: RCC . ahbrstr () . modify (| w | w . set_tscrst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . ahbenr () . modify (| w | w . set_tscen (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: TSC { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: UART4 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1 } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { unsafe { refcount_statics :: APB1ENR_UART4EN += 1 } ; if unsafe { refcount_statics :: APB1ENR_UART4EN } > 1 { return ; } # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_uart4en (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_uart4rst (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_uart4rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { unsafe { refcount_statics :: APB1ENR_UART4EN -= 1 } ; if unsafe { refcount_statics :: APB1ENR_UART4EN } > 0 { return ; } crate :: pac :: RCC . apb1enr () . modify (| w | w . set_uart4en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: UART4 { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: UART5 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1 } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { unsafe { refcount_statics :: APB1ENR_UART5EN += 1 } ; if unsafe { refcount_statics :: APB1ENR_UART5EN } > 1 { return ; } # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_uart5en (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_uart5rst (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_uart5rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { unsafe { refcount_statics :: APB1ENR_UART5EN -= 1 } ; if unsafe { refcount_statics :: APB1ENR_UART5EN } > 0 { return ; } crate :: pac :: RCC . apb1enr () . modify (| w | w . set_uart5en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: UART5 { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: USART1 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk2 } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { unsafe { refcount_statics :: APB2ENR_USART1EN += 1 } ; if unsafe { refcount_statics :: APB2ENR_USART1EN } > 1 { return ; } # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb2enr () . modify (| w | w . set_usart1en (true)) ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_usart1rst (true)) ; crate :: pac :: RCC . apb2rstr () . modify (| w | w . set_usart1rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { unsafe { refcount_statics :: APB2ENR_USART1EN -= 1 } ; if unsafe { refcount_statics :: APB2ENR_USART1EN } > 0 { return ; } crate :: pac :: RCC . apb2enr () . modify (| w | w . set_usart1en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: USART1 { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: USART2 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1 } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { unsafe { refcount_statics :: APB1ENR_USART2EN += 1 } ; if unsafe { refcount_statics :: APB1ENR_USART2EN } > 1 { return ; } # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_usart2en (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_usart2rst (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_usart2rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { unsafe { refcount_statics :: APB1ENR_USART2EN -= 1 } ; if unsafe { refcount_statics :: APB1ENR_USART2EN } > 0 { return ; } crate :: pac :: RCC . apb1enr () . modify (| w | w . set_usart2en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: USART2 { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: USART3 { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1 } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { unsafe { refcount_statics :: APB1ENR_USART3EN += 1 } ; if unsafe { refcount_statics :: APB1ENR_USART3EN } > 1 { return ; } # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_usart3en (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_usart3rst (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_usart3rst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { unsafe { refcount_statics :: APB1ENR_USART3EN -= 1 } ; if unsafe { refcount_statics :: APB1ENR_USART3EN } > 0 { return ; } crate :: pac :: RCC . apb1enr () . modify (| w | w . set_usart3en (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: USART3 { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: USB { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1 } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_usben (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_usbrst (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_usbrst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb1enr () . modify (| w | w . set_usben (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: USB { } impl crate :: rcc :: sealed :: RccPeripheral for peripherals :: WWDG { fn frequency () -> crate :: time :: Hertz { unsafe { crate :: rcc :: get_freqs () . pclk1 } } fn enable_and_reset_with_cs (_cs : critical_section :: CriticalSection) { # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 += 1 } ; crate :: pac :: RCC . apb1enr () . modify (| w | w . set_wwdgen (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_wwdgrst (true)) ; crate :: pac :: RCC . apb1rstr () . modify (| w | w . set_wwdgrst (false)) ; } fn disable_with_cs (_cs : critical_section :: CriticalSection) { crate :: pac :: RCC . apb1enr () . modify (| w | w . set_wwdgen (false)) ; # [cfg (feature = "low-power")] unsafe { crate :: rcc :: REFCOUNT_STOP1 -= 1 } ; } } impl crate :: rcc :: RccPeripheral for peripherals :: WWDG { } mod refcount_statics { pub (crate) static mut AHBENR_ADC12EN : u8 = 0 ; pub (crate) static mut AHBENR_ADC34EN : u8 = 0 ; pub (crate) static mut APB1ENR_UART4EN : u8 = 0 ; pub (crate) static mut APB1ENR_UART5EN : u8 = 0 ; pub (crate) static mut APB1ENR_USART2EN : u8 = 0 ; pub (crate) static mut APB1ENR_USART3EN : u8 = 0 ; pub (crate) static mut APB2ENR_USART1EN : u8 = 0 ; } pub unsafe fn init_dma () { } pub unsafe fn init_bdma () { crate :: pac :: RCC . ahbenr () . modify (| w | w . set_dma1en (true)) ; crate :: pac :: RCC . ahbenr () . modify (| w | w . set_dma2en (true)) ; } pub unsafe fn init_dmamux () { } pub unsafe fn init_gpdma () { } pub unsafe fn init_gpio () { crate :: pac :: RCC . ahbenr () . modify (| w | w . set_gpioaen (true)) ; crate :: pac :: RCC . ahbenr () . modify (| w | w . set_gpioben (true)) ; crate :: pac :: RCC . ahbenr () . modify (| w | w . set_gpiocen (true)) ; crate :: pac :: RCC . ahbenr () . modify (| w | w . set_gpioden (true)) ; crate :: pac :: RCC . ahbenr () . modify (| w | w . set_gpioeen (true)) ; crate :: pac :: RCC . ahbenr () . modify (| w | w . set_gpiofen (true)) ; crate :: pac :: RCC . ahbenr () . modify (| w | w . set_gpiogen (true)) ; crate :: pac :: RCC . ahbenr () . modify (| w | w . set_gpiohen (true)) ; } impl_adc_pin ! (ADC1 , PA0 , 1u8) ; impl_adc_pin ! (ADC1 , PA1 , 2u8) ; impl_adc_pin ! (ADC1 , PA2 , 3u8) ; impl_adc_pin ! (ADC1 , PA3 , 4u8) ; impl_adc_pin ! (ADC1 , PB11 , 14u8) ; impl_adc_pin ! (ADC1 , PC0 , 6u8) ; impl_adc_pin ! (ADC1 , PC1 , 7u8) ; impl_adc_pin ! (ADC1 , PC2 , 8u8) ; impl_adc_pin ! (ADC1 , PC3 , 9u8) ; impl_adc_pin ! (ADC2 , PA4 , 1u8) ; impl_adc_pin ! (ADC2 , PA5 , 2u8) ; impl_adc_pin ! (ADC2 , PA6 , 3u8) ; impl_adc_pin ! (ADC2 , PA7 , 4u8) ; impl_adc_pin ! (ADC2 , PB11 , 14u8) ; impl_adc_pin ! (ADC2 , PB2 , 12u8) ; impl_adc_pin ! (ADC2 , PC0 , 6u8) ; impl_adc_pin ! (ADC2 , PC1 , 7u8) ; impl_adc_pin ! (ADC2 , PC2 , 8u8) ; impl_adc_pin ! (ADC2 , PC3 , 9u8) ; impl_adc_pin ! (ADC2 , PC4 , 5u8) ; impl_adc_pin ! (ADC2 , PC5 , 11u8) ; impl_adc_pin ! (ADC3 , PB0 , 12u8) ; impl_adc_pin ! (ADC3 , PB1 , 1u8) ; impl_adc_pin ! (ADC3 , PB13 , 5u8) ; impl_adc_pin ! (ADC4 , PB12 , 3u8) ; impl_adc_pin ! (ADC4 , PB14 , 4u8) ; impl_adc_pin ! (ADC4 , PB15 , 5u8) ; pin_trait_impl ! (crate :: can :: RxPin , CAN , PA11 , 9u8) ; pin_trait_impl ! (crate :: can :: TxPin , CAN , PA12 , 9u8) ; pin_trait_impl ! (crate :: can :: RxPin , CAN , PB8 , 9u8) ; pin_trait_impl ! (crate :: can :: TxPin , CAN , PB9 , 9u8) ; impl_dac_pin ! (DAC1 , PA4 , 1u8) ; impl_dac_pin ! (DAC1 , PA5 , 2u8) ; pin_trait_impl ! (crate :: i2c :: SdaPin , I2C1 , PA14 , 4u8) ; pin_trait_impl ! (crate :: i2c :: SclPin , I2C1 , PA15 , 4u8) ; pin_trait_impl ! (crate :: i2c :: SclPin , I2C1 , PB6 , 4u8) ; pin_trait_impl ! (crate :: i2c :: SdaPin , I2C1 , PB7 , 4u8) ; pin_trait_impl ! (crate :: i2c :: SclPin , I2C1 , PB8 , 4u8) ; pin_trait_impl ! (crate :: i2c :: SdaPin , I2C1 , PB9 , 4u8) ; pin_trait_impl ! (crate :: i2c :: SdaPin , I2C2 , PA10 , 4u8) ; pin_trait_impl ! (crate :: i2c :: SclPin , I2C2 , PA9 , 4u8) ; pin_trait_impl ! (crate :: i2c :: SdaPin , I2C2 , PF0 , 4u8) ; pin_trait_impl ! (crate :: i2c :: SclPin , I2C2 , PF1 , 4u8) ; pin_trait_impl ! (crate :: i2c :: SclPin , I2C3 , PA8 , 3u8) ; pin_trait_impl ! (crate :: i2c :: SdaPin , I2C3 , PB5 , 8u8) ; pin_trait_impl ! (crate :: i2c :: SdaPin , I2C3 , PC9 , 3u8) ; impl_opamp_vout_pin ! (OPAMP1 , PA2) ; impl_opamp_vp_pin ! (OPAMP1 , PA7 , 0u8) ; impl_opamp_vp_pin ! (OPAMP1 , PA5 , 1u8) ; impl_opamp_vp_pin ! (OPAMP1 , PA3 , 2u8) ; impl_opamp_vp_pin ! (OPAMP1 , PA1 , 3u8) ; impl_opamp_vout_pin ! (OPAMP2 , PA6) ; impl_opamp_vp_pin ! (OPAMP2 , PD14 , 0u8) ; impl_opamp_vp_pin ! (OPAMP2 , PB14 , 1u8) ; impl_opamp_vp_pin ! (OPAMP2 , PB0 , 2u8) ; impl_opamp_vp_pin ! (OPAMP2 , PA7 , 3u8) ; impl_opamp_vout_pin ! (OPAMP3 , PB1) ; impl_opamp_vp_pin ! (OPAMP3 , PB13 , 0u8) ; impl_opamp_vp_pin ! (OPAMP3 , PA5 , 1u8) ; impl_opamp_vp_pin ! (OPAMP3 , PA1 , 2u8) ; impl_opamp_vp_pin ! (OPAMP3 , PB0 , 3u8) ; impl_opamp_vout_pin ! (OPAMP4 , PB12) ; impl_opamp_vp_pin ! (OPAMP4 , PD11 , 0u8) ; impl_opamp_vp_pin ! (OPAMP4 , PB11 , 1u8) ; impl_opamp_vp_pin ! (OPAMP4 , PA4 , 2u8) ; impl_opamp_vp_pin ! (OPAMP4 , PB13 , 3u8) ; pin_trait_impl ! (crate :: rcc :: McoPin , MCO , PA8 , 0u8) ; pin_trait_impl ! (crate :: spi :: CsPin , SPI1 , PA15 , 5u8) ; pin_trait_impl ! (crate :: spi :: CsPin , SPI1 , PA4 , 5u8) ; pin_trait_impl ! (crate :: spi :: SckPin , SPI1 , PA5 , 5u8) ; pin_trait_impl ! (crate :: spi :: MisoPin , SPI1 , PA6 , 5u8) ; pin_trait_impl ! (crate :: spi :: MosiPin , SPI1 , PA7 , 5u8) ; pin_trait_impl ! (crate :: spi :: SckPin , SPI1 , PB3 , 5u8) ; pin_trait_impl ! (crate :: spi :: MisoPin , SPI1 , PB4 , 5u8) ; pin_trait_impl ! (crate :: spi :: MosiPin , SPI1 , PB5 , 5u8) ; pin_trait_impl ! (crate :: spi :: MisoPin , SPI2 , PA10 , 5u8) ; pin_trait_impl ! (crate :: spi :: MosiPin , SPI2 , PA11 , 5u8) ; pin_trait_impl ! (crate :: spi :: MckPin , SPI2 , PA8 , 5u8) ; pin_trait_impl ! (crate :: spi :: WsPin , SPI2 , PB12 , 5u8) ; pin_trait_impl ! (crate :: spi :: CsPin , SPI2 , PB12 , 5u8) ; pin_trait_impl ! (crate :: spi :: CkPin , SPI2 , PB13 , 5u8) ; pin_trait_impl ! (crate :: spi :: SckPin , SPI2 , PB13 , 5u8) ; pin_trait_impl ! (crate :: spi :: MisoPin , SPI2 , PB14 , 5u8) ; pin_trait_impl ! (crate :: spi :: MosiPin , SPI2 , PB15 , 5u8) ; pin_trait_impl ! (crate :: spi :: MckPin , SPI2 , PC6 , 6u8) ; pin_trait_impl ! (crate :: spi :: WsPin , SPI2 , PF0 , 5u8) ; pin_trait_impl ! (crate :: spi :: CsPin , SPI2 , PF0 , 5u8) ; pin_trait_impl ! (crate :: spi :: CkPin , SPI2 , PF1 , 5u8) ; pin_trait_impl ! (crate :: spi :: SckPin , SPI2 , PF1 , 5u8) ; pin_trait_impl ! (crate :: spi :: WsPin , SPI3 , PA15 , 6u8) ; pin_trait_impl ! (crate :: spi :: CsPin , SPI3 , PA15 , 6u8) ; pin_trait_impl ! (crate :: spi :: WsPin , SPI3 , PA4 , 6u8) ; pin_trait_impl ! (crate :: spi :: CsPin , SPI3 , PA4 , 6u8) ; pin_trait_impl ! (crate :: spi :: MckPin , SPI3 , PA9 , 5u8) ; pin_trait_impl ! (crate :: spi :: CkPin , SPI3 , PB3 , 6u8) ; pin_trait_impl ! (crate :: spi :: SckPin , SPI3 , PB3 , 6u8) ; pin_trait_impl ! (crate :: spi :: MisoPin , SPI3 , PB4 , 6u8) ; pin_trait_impl ! (crate :: spi :: MosiPin , SPI3 , PB5 , 6u8) ; pin_trait_impl ! (crate :: spi :: CkPin , SPI3 , PC10 , 6u8) ; pin_trait_impl ! (crate :: spi :: SckPin , SPI3 , PC10 , 6u8) ; pin_trait_impl ! (crate :: spi :: MisoPin , SPI3 , PC11 , 6u8) ; pin_trait_impl ! (crate :: spi :: MosiPin , SPI3 , PC12 , 6u8) ; pin_trait_impl ! (crate :: spi :: MckPin , SPI3 , PC7 , 6u8) ; pin_trait_impl ! (crate :: timer :: Channel3Pin , TIM1 , PA10 , 6u8) ; pin_trait_impl ! (crate :: timer :: BreakInput2Pin , TIM1 , PA11 , 12u8) ; pin_trait_impl ! (crate :: timer :: Channel1ComplementaryPin , TIM1 , PA11 , 6u8) ; pin_trait_impl ! (crate :: timer :: Channel4Pin , TIM1 , PA11 , 11u8) ; pin_trait_impl ! (crate :: timer :: Channel2ComplementaryPin , TIM1 , PA12 , 6u8) ; pin_trait_impl ! (crate :: timer :: ExternalTriggerPin , TIM1 , PA12 , 11u8) ; pin_trait_impl ! (crate :: timer :: BreakInputPin , TIM1 , PA14 , 6u8) ; pin_trait_impl ! (crate :: timer :: BreakInputPin , TIM1 , PA15 , 9u8) ; pin_trait_impl ! (crate :: timer :: BreakInputPin , TIM1 , PA6 , 6u8) ; pin_trait_impl ! (crate :: timer :: Channel1ComplementaryPin , TIM1 , PA7 , 6u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM1 , PA8 , 6u8) ; pin_trait_impl ! (crate :: timer :: Channel2Pin , TIM1 , PA9 , 6u8) ; pin_trait_impl ! (crate :: timer :: Channel2ComplementaryPin , TIM1 , PB0 , 6u8) ; pin_trait_impl ! (crate :: timer :: Channel3ComplementaryPin , TIM1 , PB1 , 6u8) ; pin_trait_impl ! (crate :: timer :: BreakInputPin , TIM1 , PB12 , 6u8) ; pin_trait_impl ! (crate :: timer :: Channel1ComplementaryPin , TIM1 , PB13 , 6u8) ; pin_trait_impl ! (crate :: timer :: Channel2ComplementaryPin , TIM1 , PB14 , 6u8) ; pin_trait_impl ! (crate :: timer :: Channel3ComplementaryPin , TIM1 , PB15 , 4u8) ; pin_trait_impl ! (crate :: timer :: BreakInputPin , TIM1 , PB8 , 12u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM1 , PC0 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel2Pin , TIM1 , PC1 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel1ComplementaryPin , TIM1 , PC13 , 4u8) ; pin_trait_impl ! (crate :: timer :: Channel3Pin , TIM1 , PC2 , 2u8) ; pin_trait_impl ! (crate :: timer :: BreakInput2Pin , TIM1 , PC3 , 6u8) ; pin_trait_impl ! (crate :: timer :: Channel4Pin , TIM1 , PC3 , 2u8) ; pin_trait_impl ! (crate :: timer :: ExternalTriggerPin , TIM1 , PC4 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel3ComplementaryPin , TIM1 , PF0 , 6u8) ; pin_trait_impl ! (crate :: timer :: Channel1ComplementaryPin , TIM15 , PA1 , 9u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM15 , PA2 , 9u8) ; pin_trait_impl ! (crate :: timer :: Channel2Pin , TIM15 , PA3 , 9u8) ; pin_trait_impl ! (crate :: timer :: BreakInputPin , TIM15 , PA9 , 9u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM15 , PB14 , 1u8) ; pin_trait_impl ! (crate :: timer :: Channel1ComplementaryPin , TIM15 , PB15 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel2Pin , TIM15 , PB15 , 1u8) ; pin_trait_impl ! (crate :: timer :: BreakInputPin , TIM15 , PC5 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM16 , PA12 , 1u8) ; pin_trait_impl ! (crate :: timer :: Channel1ComplementaryPin , TIM16 , PA13 , 1u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM16 , PA6 , 1u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM16 , PB4 , 1u8) ; pin_trait_impl ! (crate :: timer :: BreakInputPin , TIM16 , PB5 , 1u8) ; pin_trait_impl ! (crate :: timer :: Channel1ComplementaryPin , TIM16 , PB6 , 1u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM16 , PB8 , 1u8) ; pin_trait_impl ! (crate :: timer :: BreakInputPin , TIM17 , PA10 , 1u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM17 , PA7 , 1u8) ; pin_trait_impl ! (crate :: timer :: BreakInputPin , TIM17 , PB4 , 10u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM17 , PB5 , 10u8) ; pin_trait_impl ! (crate :: timer :: Channel1ComplementaryPin , TIM17 , PB7 , 1u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM17 , PB9 , 1u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM2 , PA0 , 1u8) ; pin_trait_impl ! (crate :: timer :: ExternalTriggerPin , TIM2 , PA0 , 1u8) ; pin_trait_impl ! (crate :: timer :: Channel2Pin , TIM2 , PA1 , 1u8) ; pin_trait_impl ! (crate :: timer :: Channel4Pin , TIM2 , PA10 , 10u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM2 , PA15 , 1u8) ; pin_trait_impl ! (crate :: timer :: ExternalTriggerPin , TIM2 , PA15 , 1u8) ; pin_trait_impl ! (crate :: timer :: Channel3Pin , TIM2 , PA2 , 1u8) ; pin_trait_impl ! (crate :: timer :: Channel4Pin , TIM2 , PA3 , 1u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM2 , PA5 , 1u8) ; pin_trait_impl ! (crate :: timer :: ExternalTriggerPin , TIM2 , PA5 , 1u8) ; pin_trait_impl ! (crate :: timer :: Channel3Pin , TIM2 , PA9 , 10u8) ; pin_trait_impl ! (crate :: timer :: Channel3Pin , TIM2 , PB10 , 1u8) ; pin_trait_impl ! (crate :: timer :: Channel4Pin , TIM2 , PB11 , 1u8) ; pin_trait_impl ! (crate :: timer :: Channel2Pin , TIM2 , PB3 , 1u8) ; pin_trait_impl ! (crate :: timer :: Channel2Pin , TIM3 , PA4 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM3 , PA6 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel2Pin , TIM3 , PA7 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel3Pin , TIM3 , PB0 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel4Pin , TIM3 , PB1 , 2u8) ; pin_trait_impl ! (crate :: timer :: ExternalTriggerPin , TIM3 , PB3 , 10u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM3 , PB4 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel2Pin , TIM3 , PB5 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel4Pin , TIM3 , PB7 , 10u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM3 , PC6 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel2Pin , TIM3 , PC7 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel3Pin , TIM3 , PC8 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel4Pin , TIM3 , PC9 , 2u8) ; pin_trait_impl ! (crate :: timer :: ExternalTriggerPin , TIM3 , PD2 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM4 , PA11 , 10u8) ; pin_trait_impl ! (crate :: timer :: Channel2Pin , TIM4 , PA12 , 10u8) ; pin_trait_impl ! (crate :: timer :: Channel3Pin , TIM4 , PA13 , 10u8) ; pin_trait_impl ! (crate :: timer :: ExternalTriggerPin , TIM4 , PA8 , 10u8) ; pin_trait_impl ! (crate :: timer :: ExternalTriggerPin , TIM4 , PB3 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM4 , PB6 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel2Pin , TIM4 , PB7 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel3Pin , TIM4 , PB8 , 2u8) ; pin_trait_impl ! (crate :: timer :: Channel4Pin , TIM4 , PB9 , 2u8) ; pin_trait_impl ! (crate :: timer :: BreakInputPin , TIM8 , PA0 , 9u8) ; pin_trait_impl ! (crate :: timer :: ExternalTriggerPin , TIM8 , PA0 , 10u8) ; pin_trait_impl ! (crate :: timer :: BreakInputPin , TIM8 , PA10 , 11u8) ; pin_trait_impl ! (crate :: timer :: Channel2Pin , TIM8 , PA14 , 5u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM8 , PA15 , 2u8) ; pin_trait_impl ! (crate :: timer :: BreakInputPin , TIM8 , PA6 , 4u8) ; pin_trait_impl ! (crate :: timer :: Channel1ComplementaryPin , TIM8 , PA7 , 4u8) ; pin_trait_impl ! (crate :: timer :: Channel2ComplementaryPin , TIM8 , PB0 , 4u8) ; pin_trait_impl ! (crate :: timer :: Channel3ComplementaryPin , TIM8 , PB1 , 4u8) ; pin_trait_impl ! (crate :: timer :: Channel1ComplementaryPin , TIM8 , PB3 , 4u8) ; pin_trait_impl ! (crate :: timer :: Channel2ComplementaryPin , TIM8 , PB4 , 4u8) ; pin_trait_impl ! (crate :: timer :: Channel3ComplementaryPin , TIM8 , PB5 , 3u8) ; pin_trait_impl ! (crate :: timer :: BreakInput2Pin , TIM8 , PB6 , 10u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM8 , PB6 , 5u8) ; pin_trait_impl ! (crate :: timer :: ExternalTriggerPin , TIM8 , PB6 , 6u8) ; pin_trait_impl ! (crate :: timer :: BreakInputPin , TIM8 , PB7 , 5u8) ; pin_trait_impl ! (crate :: timer :: Channel2Pin , TIM8 , PB8 , 10u8) ; pin_trait_impl ! (crate :: timer :: Channel3Pin , TIM8 , PB9 , 10u8) ; pin_trait_impl ! (crate :: timer :: Channel1ComplementaryPin , TIM8 , PC10 , 4u8) ; pin_trait_impl ! (crate :: timer :: Channel2ComplementaryPin , TIM8 , PC11 , 4u8) ; pin_trait_impl ! (crate :: timer :: Channel3ComplementaryPin , TIM8 , PC12 , 4u8) ; pin_trait_impl ! (crate :: timer :: Channel1Pin , TIM8 , PC6 , 4u8) ; pin_trait_impl ! (crate :: timer :: Channel2Pin , TIM8 , PC7 , 4u8) ; pin_trait_impl ! (crate :: timer :: Channel3Pin , TIM8 , PC8 , 4u8) ; pin_trait_impl ! (crate :: timer :: BreakInput2Pin , TIM8 , PC9 , 6u8) ; pin_trait_impl ! (crate :: timer :: Channel4Pin , TIM8 , PC9 , 4u8) ; pin_trait_impl ! (crate :: timer :: BreakInputPin , TIM8 , PD2 , 4u8) ; pin_trait_impl ! (crate :: usart :: TxPin , UART4 , PC10 , 5u8) ; pin_trait_impl ! (crate :: usart :: RxPin , UART4 , PC11 , 5u8) ; pin_trait_impl ! (crate :: usart :: TxPin , UART5 , PC12 , 5u8) ; pin_trait_impl ! (crate :: usart :: RxPin , UART5 , PD2 , 5u8) ; pin_trait_impl ! (crate :: usart :: RxPin , USART1 , PA10 , 7u8) ; pin_trait_impl ! (crate :: usart :: CtsPin , USART1 , PA11 , 7u8) ; pin_trait_impl ! (crate :: usart :: DePin , USART1 , PA12 , 7u8) ; pin_trait_impl ! (crate :: usart :: RtsPin , USART1 , PA12 , 7u8) ; pin_trait_impl ! (crate :: usart :: CkPin , USART1 , PA8 , 7u8) ; pin_trait_impl ! (crate :: usart :: TxPin , USART1 , PA9 , 7u8) ; pin_trait_impl ! (crate :: usart :: TxPin , USART1 , PB6 , 7u8) ; pin_trait_impl ! (crate :: usart :: RxPin , USART1 , PB7 , 7u8) ; pin_trait_impl ! (crate :: usart :: TxPin , USART1 , PC4 , 7u8) ; pin_trait_impl ! (crate :: usart :: RxPin , USART1 , PC5 , 7u8) ; pin_trait_impl ! (crate :: usart :: CtsPin , USART2 , PA0 , 7u8) ; pin_trait_impl ! (crate :: usart :: DePin , USART2 , PA1 , 7u8) ; pin_trait_impl ! (crate :: usart :: RtsPin , USART2 , PA1 , 7u8) ; pin_trait_impl ! (crate :: usart :: TxPin , USART2 , PA14 , 7u8) ; pin_trait_impl ! (crate :: usart :: RxPin , USART2 , PA15 , 7u8) ; pin_trait_impl ! (crate :: usart :: TxPin , USART2 , PA2 , 7u8) ; pin_trait_impl ! (crate :: usart :: RxPin , USART2 , PA3 , 7u8) ; pin_trait_impl ! (crate :: usart :: CkPin , USART2 , PA4 , 7u8) ; pin_trait_impl ! (crate :: usart :: TxPin , USART2 , PB3 , 7u8) ; pin_trait_impl ! (crate :: usart :: RxPin , USART2 , PB4 , 7u8) ; pin_trait_impl ! (crate :: usart :: CkPin , USART2 , PB5 , 7u8) ; pin_trait_impl ! (crate :: usart :: CtsPin , USART3 , PA13 , 7u8) ; pin_trait_impl ! (crate :: usart :: TxPin , USART3 , PB10 , 7u8) ; pin_trait_impl ! (crate :: usart :: RxPin , USART3 , PB11 , 7u8) ; pin_trait_impl ! (crate :: usart :: CkPin , USART3 , PB12 , 7u8) ; pin_trait_impl ! (crate :: usart :: CtsPin , USART3 , PB13 , 7u8) ; pin_trait_impl ! (crate :: usart :: DePin , USART3 , PB14 , 7u8) ; pin_trait_impl ! (crate :: usart :: RtsPin , USART3 , PB14 , 7u8) ; pin_trait_impl ! (crate :: usart :: RxPin , USART3 , PB8 , 7u8) ; pin_trait_impl ! (crate :: usart :: TxPin , USART3 , PB9 , 7u8) ; pin_trait_impl ! (crate :: usart :: TxPin , USART3 , PC10 , 7u8) ; pin_trait_impl ! (crate :: usart :: RxPin , USART3 , PC11 , 7u8) ; pin_trait_impl ! (crate :: usart :: CkPin , USART3 , PC12 , 7u8) ; pin_trait_impl ! (crate :: usb :: DmPin , USB , PA11 , 0u8) ; pin_trait_impl ! (crate :: usb :: DpPin , USB , PA12 , 0u8) ; dma_trait_impl ! (crate :: dac :: DacDma1 , DAC1 , { channel : DMA1_CH3 } , ()) ; dma_trait_impl ! (crate :: dac :: DacDma2 , DAC1 , { channel : DMA1_CH4 } , ()) ; dma_trait_impl ! (crate :: dac :: DacDma1 , DAC1 , { channel : DMA2_CH3 } , ()) ; dma_trait_impl ! (crate :: dac :: DacDma2 , DAC1 , { channel : DMA2_CH4 } , ()) ; dma_trait_impl ! (crate :: i2c :: TxDma , I2C1 , { channel : DMA1_CH6 } , ()) ; dma_trait_impl ! (crate :: i2c :: RxDma , I2C1 , { channel : DMA1_CH7 } , ()) ; dma_trait_impl ! (crate :: i2c :: TxDma , I2C2 , { channel : DMA1_CH4 } , ()) ; dma_trait_impl ! (crate :: i2c :: RxDma , I2C2 , { channel : DMA1_CH5 } , ()) ; dma_trait_impl ! (crate :: i2c :: TxDma , I2C3 , { channel : DMA1_CH1 } , ()) ; dma_trait_impl ! (crate :: i2c :: RxDma , I2C3 , { channel : DMA1_CH2 } , ()) ; dma_trait_impl ! (crate :: spi :: RxDma , SPI1 , { channel : DMA1_CH2 } , ()) ; dma_trait_impl ! (crate :: spi :: TxDma , SPI1 , { channel : DMA1_CH3 } , ()) ; dma_trait_impl ! (crate :: spi :: RxDma , SPI2 , { channel : DMA1_CH4 } , ()) ; dma_trait_impl ! (crate :: spi :: TxDma , SPI2 , { channel : DMA1_CH5 } , ()) ; dma_trait_impl ! (crate :: spi :: RxDma , SPI3 , { channel : DMA2_CH1 } , ()) ; dma_trait_impl ! (crate :: spi :: TxDma , SPI3 , { channel : DMA2_CH2 } , ()) ; dma_trait_impl ! (crate :: timer :: UpDma , TIM1 , { channel : DMA1_CH5 } , ()) ; dma_trait_impl ! (crate :: timer :: UpDma , TIM15 , { channel : DMA1_CH5 } , ()) ; dma_trait_impl ! (crate :: timer :: UpDma , TIM16 , { channel : DMA1_CH3 } , ()) ; dma_trait_impl ! (crate :: timer :: UpDma , TIM16 , { channel : DMA1_CH6 } , ()) ; dma_trait_impl ! (crate :: timer :: UpDma , TIM17 , { channel : DMA1_CH1 } , ()) ; dma_trait_impl ! (crate :: timer :: UpDma , TIM17 , { channel : DMA1_CH7 } , ()) ; dma_trait_impl ! (crate :: timer :: UpDma , TIM2 , { channel : DMA1_CH2 } , ()) ; dma_trait_impl ! (crate :: timer :: UpDma , TIM3 , { channel : DMA1_CH3 } , ()) ; dma_trait_impl ! (crate :: timer :: UpDma , TIM4 , { channel : DMA1_CH7 } , ()) ; dma_trait_impl ! (crate :: timer :: UpDma , TIM6 , { channel : DMA1_CH3 } , ()) ; dma_trait_impl ! (crate :: timer :: UpDma , TIM6 , { channel : DMA2_CH3 } , ()) ; dma_trait_impl ! (crate :: timer :: UpDma , TIM7 , { channel : DMA1_CH4 } , ()) ; dma_trait_impl ! (crate :: timer :: UpDma , TIM7 , { channel : DMA2_CH4 } , ()) ; dma_trait_impl ! (crate :: timer :: UpDma , TIM8 , { channel : DMA2_CH1 } , ()) ; dma_trait_impl ! (crate :: usart :: RxDma , UART4 , { channel : DMA2_CH3 } , ()) ; dma_trait_impl ! (crate :: usart :: TxDma , UART4 , { channel : DMA2_CH5 } , ()) ; dma_trait_impl ! (crate :: usart :: TxDma , USART1 , { channel : DMA1_CH4 } , ()) ; dma_trait_impl ! (crate :: usart :: RxDma , USART1 , { channel : DMA1_CH5 } , ()) ; dma_trait_impl ! (crate :: usart :: RxDma , USART2 , { channel : DMA1_CH6 } , ()) ; dma_trait_impl ! (crate :: usart :: TxDma , USART2 , { channel : DMA1_CH7 } , ()) ; dma_trait_impl ! (crate :: usart :: TxDma , USART3 , { channel : DMA1_CH2 } , ()) ; dma_trait_impl ! (crate :: usart :: RxDma , USART3 , { channel : DMA1_CH3 } , ()) ; impl core :: ops :: Div < crate :: pac :: rcc :: vals :: Adcpre > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn div (self , rhs : crate :: pac :: rcc :: vals :: Adcpre) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Adcpre :: DIV2 => self * 1u32 / 2u32 , crate :: pac :: rcc :: vals :: Adcpre :: DIV4 => self * 1u32 / 4u32 , crate :: pac :: rcc :: vals :: Adcpre :: DIV6 => self * 1u32 / 6u32 , crate :: pac :: rcc :: vals :: Adcpre :: DIV8 => self * 1u32 / 8u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Mul < crate :: pac :: rcc :: vals :: Adcpre > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn mul (self , rhs : crate :: pac :: rcc :: vals :: Adcpre) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Adcpre :: DIV2 => self * 2u32 / 1u32 , crate :: pac :: rcc :: vals :: Adcpre :: DIV4 => self * 4u32 / 1u32 , crate :: pac :: rcc :: vals :: Adcpre :: DIV6 => self * 6u32 / 1u32 , crate :: pac :: rcc :: vals :: Adcpre :: DIV8 => self * 8u32 / 1u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Div < crate :: pac :: rcc :: vals :: Adcpres > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn div (self , rhs : crate :: pac :: rcc :: vals :: Adcpres) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Adcpres :: DIV1 => self * 1u32 / 1u32 , crate :: pac :: rcc :: vals :: Adcpres :: DIV2 => self * 1u32 / 2u32 , crate :: pac :: rcc :: vals :: Adcpres :: DIV4 => self * 1u32 / 4u32 , crate :: pac :: rcc :: vals :: Adcpres :: DIV6 => self * 1u32 / 6u32 , crate :: pac :: rcc :: vals :: Adcpres :: DIV8 => self * 1u32 / 8u32 , crate :: pac :: rcc :: vals :: Adcpres :: DIV10 => self * 1u32 / 10u32 , crate :: pac :: rcc :: vals :: Adcpres :: DIV12 => self * 1u32 / 12u32 , crate :: pac :: rcc :: vals :: Adcpres :: DIV16 => self * 1u32 / 16u32 , crate :: pac :: rcc :: vals :: Adcpres :: DIV32 => self * 1u32 / 32u32 , crate :: pac :: rcc :: vals :: Adcpres :: DIV64 => self * 1u32 / 64u32 , crate :: pac :: rcc :: vals :: Adcpres :: DIV128 => self * 1u32 / 128u32 , crate :: pac :: rcc :: vals :: Adcpres :: DIV256 => self * 1u32 / 256u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Mul < crate :: pac :: rcc :: vals :: Adcpres > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn mul (self , rhs : crate :: pac :: rcc :: vals :: Adcpres) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Adcpres :: DIV1 => self * 1u32 / 1u32 , crate :: pac :: rcc :: vals :: Adcpres :: DIV2 => self * 2u32 / 1u32 , crate :: pac :: rcc :: vals :: Adcpres :: DIV4 => self * 4u32 / 1u32 , crate :: pac :: rcc :: vals :: Adcpres :: DIV6 => self * 6u32 / 1u32 , crate :: pac :: rcc :: vals :: Adcpres :: DIV8 => self * 8u32 / 1u32 , crate :: pac :: rcc :: vals :: Adcpres :: DIV10 => self * 10u32 / 1u32 , crate :: pac :: rcc :: vals :: Adcpres :: DIV12 => self * 12u32 / 1u32 , crate :: pac :: rcc :: vals :: Adcpres :: DIV16 => self * 16u32 / 1u32 , crate :: pac :: rcc :: vals :: Adcpres :: DIV32 => self * 32u32 / 1u32 , crate :: pac :: rcc :: vals :: Adcpres :: DIV64 => self * 64u32 / 1u32 , crate :: pac :: rcc :: vals :: Adcpres :: DIV128 => self * 128u32 / 1u32 , crate :: pac :: rcc :: vals :: Adcpres :: DIV256 => self * 256u32 / 1u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Div < crate :: pac :: rcc :: vals :: Hpre > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn div (self , rhs : crate :: pac :: rcc :: vals :: Hpre) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Hpre :: DIV1 => self * 1u32 / 1u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV2 => self * 1u32 / 2u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV4 => self * 1u32 / 4u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV8 => self * 1u32 / 8u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV16 => self * 1u32 / 16u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV64 => self * 1u32 / 64u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV128 => self * 1u32 / 128u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV256 => self * 1u32 / 256u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV512 => self * 1u32 / 512u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Mul < crate :: pac :: rcc :: vals :: Hpre > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn mul (self , rhs : crate :: pac :: rcc :: vals :: Hpre) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Hpre :: DIV1 => self * 1u32 / 1u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV2 => self * 2u32 / 1u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV4 => self * 4u32 / 1u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV8 => self * 8u32 / 1u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV16 => self * 16u32 / 1u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV64 => self * 64u32 / 1u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV128 => self * 128u32 / 1u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV256 => self * 256u32 / 1u32 , crate :: pac :: rcc :: vals :: Hpre :: DIV512 => self * 512u32 / 1u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Div < crate :: pac :: rcc :: vals :: Mcopre > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn div (self , rhs : crate :: pac :: rcc :: vals :: Mcopre) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Mcopre :: DIV1 => self * 1u32 / 1u32 , crate :: pac :: rcc :: vals :: Mcopre :: DIV2 => self * 1u32 / 2u32 , crate :: pac :: rcc :: vals :: Mcopre :: DIV4 => self * 1u32 / 4u32 , crate :: pac :: rcc :: vals :: Mcopre :: DIV8 => self * 1u32 / 8u32 , crate :: pac :: rcc :: vals :: Mcopre :: DIV16 => self * 1u32 / 16u32 , crate :: pac :: rcc :: vals :: Mcopre :: DIV32 => self * 1u32 / 32u32 , crate :: pac :: rcc :: vals :: Mcopre :: DIV64 => self * 1u32 / 64u32 , crate :: pac :: rcc :: vals :: Mcopre :: DIV128 => self * 1u32 / 128u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Mul < crate :: pac :: rcc :: vals :: Mcopre > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn mul (self , rhs : crate :: pac :: rcc :: vals :: Mcopre) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Mcopre :: DIV1 => self * 1u32 / 1u32 , crate :: pac :: rcc :: vals :: Mcopre :: DIV2 => self * 2u32 / 1u32 , crate :: pac :: rcc :: vals :: Mcopre :: DIV4 => self * 4u32 / 1u32 , crate :: pac :: rcc :: vals :: Mcopre :: DIV8 => self * 8u32 / 1u32 , crate :: pac :: rcc :: vals :: Mcopre :: DIV16 => self * 16u32 / 1u32 , crate :: pac :: rcc :: vals :: Mcopre :: DIV32 => self * 32u32 / 1u32 , crate :: pac :: rcc :: vals :: Mcopre :: DIV64 => self * 64u32 / 1u32 , crate :: pac :: rcc :: vals :: Mcopre :: DIV128 => self * 128u32 / 1u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Div < crate :: pac :: rcc :: vals :: Pllmcodiv > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn div (self , rhs : crate :: pac :: rcc :: vals :: Pllmcodiv) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Pllmcodiv :: DIV2 => self * 1u32 / 2u32 , crate :: pac :: rcc :: vals :: Pllmcodiv :: DIV1 => self * 1u32 / 1u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Mul < crate :: pac :: rcc :: vals :: Pllmcodiv > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn mul (self , rhs : crate :: pac :: rcc :: vals :: Pllmcodiv) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Pllmcodiv :: DIV2 => self * 2u32 / 1u32 , crate :: pac :: rcc :: vals :: Pllmcodiv :: DIV1 => self * 1u32 / 1u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Div < crate :: pac :: rcc :: vals :: Pllmul > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn div (self , rhs : crate :: pac :: rcc :: vals :: Pllmul) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Pllmul :: MUL2 => self * 1u32 / 2u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL3 => self * 1u32 / 3u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL4 => self * 1u32 / 4u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL5 => self * 1u32 / 5u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL6 => self * 1u32 / 6u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL7 => self * 1u32 / 7u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL8 => self * 1u32 / 8u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL9 => self * 1u32 / 9u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL10 => self * 1u32 / 10u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL11 => self * 1u32 / 11u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL12 => self * 1u32 / 12u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL13 => self * 1u32 / 13u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL14 => self * 1u32 / 14u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL15 => self * 1u32 / 15u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL16 => self * 1u32 / 16u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Mul < crate :: pac :: rcc :: vals :: Pllmul > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn mul (self , rhs : crate :: pac :: rcc :: vals :: Pllmul) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Pllmul :: MUL2 => self * 2u32 / 1u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL3 => self * 3u32 / 1u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL4 => self * 4u32 / 1u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL5 => self * 5u32 / 1u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL6 => self * 6u32 / 1u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL7 => self * 7u32 / 1u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL8 => self * 8u32 / 1u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL9 => self * 9u32 / 1u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL10 => self * 10u32 / 1u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL11 => self * 11u32 / 1u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL12 => self * 12u32 / 1u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL13 => self * 13u32 / 1u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL14 => self * 14u32 / 1u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL15 => self * 15u32 / 1u32 , crate :: pac :: rcc :: vals :: Pllmul :: MUL16 => self * 16u32 / 1u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Div < crate :: pac :: rcc :: vals :: Pllxtpre > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn div (self , rhs : crate :: pac :: rcc :: vals :: Pllxtpre) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Pllxtpre :: DIV1 => self * 1u32 / 1u32 , crate :: pac :: rcc :: vals :: Pllxtpre :: DIV2 => self * 1u32 / 2u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Mul < crate :: pac :: rcc :: vals :: Pllxtpre > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn mul (self , rhs : crate :: pac :: rcc :: vals :: Pllxtpre) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Pllxtpre :: DIV1 => self * 1u32 / 1u32 , crate :: pac :: rcc :: vals :: Pllxtpre :: DIV2 => self * 2u32 / 1u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Div < crate :: pac :: rcc :: vals :: Ppre > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn div (self , rhs : crate :: pac :: rcc :: vals :: Ppre) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Ppre :: DIV1 => self * 1u32 / 1u32 , crate :: pac :: rcc :: vals :: Ppre :: DIV2 => self * 1u32 / 2u32 , crate :: pac :: rcc :: vals :: Ppre :: DIV4 => self * 1u32 / 4u32 , crate :: pac :: rcc :: vals :: Ppre :: DIV8 => self * 1u32 / 8u32 , crate :: pac :: rcc :: vals :: Ppre :: DIV16 => self * 1u32 / 16u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Mul < crate :: pac :: rcc :: vals :: Ppre > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn mul (self , rhs : crate :: pac :: rcc :: vals :: Ppre) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Ppre :: DIV1 => self * 1u32 / 1u32 , crate :: pac :: rcc :: vals :: Ppre :: DIV2 => self * 2u32 / 1u32 , crate :: pac :: rcc :: vals :: Ppre :: DIV4 => self * 4u32 / 1u32 , crate :: pac :: rcc :: vals :: Ppre :: DIV8 => self * 8u32 / 1u32 , crate :: pac :: rcc :: vals :: Ppre :: DIV16 => self * 16u32 / 1u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Div < crate :: pac :: rcc :: vals :: Prediv > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn div (self , rhs : crate :: pac :: rcc :: vals :: Prediv) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Prediv :: DIV1 => self * 1u32 / 1u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV2 => self * 1u32 / 2u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV3 => self * 1u32 / 3u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV4 => self * 1u32 / 4u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV5 => self * 1u32 / 5u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV6 => self * 1u32 / 6u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV7 => self * 1u32 / 7u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV8 => self * 1u32 / 8u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV9 => self * 1u32 / 9u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV10 => self * 1u32 / 10u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV11 => self * 1u32 / 11u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV12 => self * 1u32 / 12u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV13 => self * 1u32 / 13u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV14 => self * 1u32 / 14u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV15 => self * 1u32 / 15u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV16 => self * 1u32 / 16u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Mul < crate :: pac :: rcc :: vals :: Prediv > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn mul (self , rhs : crate :: pac :: rcc :: vals :: Prediv) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Prediv :: DIV1 => self * 1u32 / 1u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV2 => self * 2u32 / 1u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV3 => self * 3u32 / 1u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV4 => self * 4u32 / 1u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV5 => self * 5u32 / 1u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV6 => self * 6u32 / 1u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV7 => self * 7u32 / 1u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV8 => self * 8u32 / 1u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV9 => self * 9u32 / 1u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV10 => self * 10u32 / 1u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV11 => self * 11u32 / 1u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV12 => self * 12u32 / 1u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV13 => self * 13u32 / 1u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV14 => self * 14u32 / 1u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV15 => self * 15u32 / 1u32 , crate :: pac :: rcc :: vals :: Prediv :: DIV16 => self * 16u32 / 1u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Div < crate :: pac :: rcc :: vals :: Sdpre > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn div (self , rhs : crate :: pac :: rcc :: vals :: Sdpre) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Sdpre :: DIV2 => self * 1u32 / 2u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV4 => self * 1u32 / 4u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV6 => self * 1u32 / 6u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV8 => self * 1u32 / 8u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV10 => self * 1u32 / 10u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV12 => self * 1u32 / 12u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV14 => self * 1u32 / 14u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV16 => self * 1u32 / 16u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV20 => self * 1u32 / 20u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV24 => self * 1u32 / 24u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV28 => self * 1u32 / 28u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV32 => self * 1u32 / 32u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV36 => self * 1u32 / 36u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV40 => self * 1u32 / 40u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV44 => self * 1u32 / 44u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV48 => self * 1u32 / 48u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Mul < crate :: pac :: rcc :: vals :: Sdpre > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn mul (self , rhs : crate :: pac :: rcc :: vals :: Sdpre) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Sdpre :: DIV2 => self * 2u32 / 1u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV4 => self * 4u32 / 1u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV6 => self * 6u32 / 1u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV8 => self * 8u32 / 1u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV10 => self * 10u32 / 1u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV12 => self * 12u32 / 1u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV14 => self * 14u32 / 1u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV16 => self * 16u32 / 1u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV20 => self * 20u32 / 1u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV24 => self * 24u32 / 1u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV28 => self * 28u32 / 1u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV32 => self * 32u32 / 1u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV36 => self * 36u32 / 1u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV40 => self * 40u32 / 1u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV44 => self * 44u32 / 1u32 , crate :: pac :: rcc :: vals :: Sdpre :: DIV48 => self * 48u32 / 1u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Div < crate :: pac :: rcc :: vals :: Usbpre > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn div (self , rhs : crate :: pac :: rcc :: vals :: Usbpre) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Usbpre :: DIV1_5 => self * 2u32 / 3u32 , crate :: pac :: rcc :: vals :: Usbpre :: DIV1 => self * 1u32 / 1u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } impl core :: ops :: Mul < crate :: pac :: rcc :: vals :: Usbpre > for crate :: time :: Hertz { type Output = crate :: time :: Hertz ; fn mul (self , rhs : crate :: pac :: rcc :: vals :: Usbpre) -> Self :: Output { match rhs { crate :: pac :: rcc :: vals :: Usbpre :: DIV1_5 => self * 3u32 / 2u32 , crate :: pac :: rcc :: vals :: Usbpre :: DIV1 => self * 1u32 / 1u32 , # [allow (unreachable_patterns)] _ => unreachable ! () , } } } # [allow (non_camel_case_types)] pub mod peripheral_interrupts { pub mod ADC1 { pub type GLOBAL = crate :: interrupt :: typelevel :: ADC1_2 ; } pub mod ADC2 { pub type GLOBAL = crate :: interrupt :: typelevel :: ADC1_2 ; } pub mod ADC3 { pub type GLOBAL = crate :: interrupt :: typelevel :: ADC3 ; } pub mod ADC3_COMMON { } pub mod ADC4 { pub type GLOBAL = crate :: interrupt :: typelevel :: ADC4 ; } pub mod ADC_COMMON { } pub mod CAN { pub type RX0 = crate :: interrupt :: typelevel :: USB_LP_CAN_RX0 ; pub type RX1 = crate :: interrupt :: typelevel :: CAN_RX1 ; pub type SCE = crate :: interrupt :: typelevel :: CAN_SCE ; pub type TX = crate :: interrupt :: typelevel :: USB_HP_CAN_TX ; } pub mod COMP1 { pub type WKUP = crate :: interrupt :: typelevel :: COMP1_2_3 ; } pub mod COMP2 { pub type WKUP = crate :: interrupt :: typelevel :: COMP1_2_3 ; } pub mod COMP3 { pub type WKUP = crate :: interrupt :: typelevel :: COMP1_2_3 ; } pub mod COMP4 { pub type WKUP = crate :: interrupt :: typelevel :: COMP4_5_6 ; } pub mod COMP5 { pub type WKUP = crate :: interrupt :: typelevel :: COMP4_5_6 ; } pub mod COMP6 { pub type WKUP = crate :: interrupt :: typelevel :: COMP4_5_6 ; } pub mod COMP7 { pub type WKUP = crate :: interrupt :: typelevel :: COMP7 ; } pub mod CRC { } pub mod DAC1 { pub type GLOBAL = crate :: interrupt :: typelevel :: TIM6_DAC ; } pub mod DBGMCU { } pub mod DMA1 { pub type CH1 = crate :: interrupt :: typelevel :: DMA1_CHANNEL1 ; pub type CH2 = crate :: interrupt :: typelevel :: DMA1_CHANNEL2 ; pub type CH3 = crate :: interrupt :: typelevel :: DMA1_CHANNEL3 ; pub type CH4 = crate :: interrupt :: typelevel :: DMA1_CHANNEL4 ; pub type CH5 = crate :: interrupt :: typelevel :: DMA1_CHANNEL5 ; pub type CH6 = crate :: interrupt :: typelevel :: DMA1_CHANNEL6 ; pub type CH7 = crate :: interrupt :: typelevel :: DMA1_CHANNEL7 ; } pub mod DMA2 { pub type CH1 = crate :: interrupt :: typelevel :: DMA2_CHANNEL1 ; pub type CH2 = crate :: interrupt :: typelevel :: DMA2_CHANNEL2 ; pub type CH3 = crate :: interrupt :: typelevel :: DMA2_CHANNEL3 ; pub type CH4 = crate :: interrupt :: typelevel :: DMA2_CHANNEL4 ; pub type CH5 = crate :: interrupt :: typelevel :: DMA2_CHANNEL5 ; } pub mod EXTI { pub type EXTI0 = crate :: interrupt :: typelevel :: EXTI0 ; pub type EXTI1 = crate :: interrupt :: typelevel :: EXTI1 ; pub type EXTI10 = crate :: interrupt :: typelevel :: EXTI15_10 ; pub type EXTI11 = crate :: interrupt :: typelevel :: EXTI15_10 ; pub type EXTI12 = crate :: interrupt :: typelevel :: EXTI15_10 ; pub type EXTI13 = crate :: interrupt :: typelevel :: EXTI15_10 ; pub type EXTI14 = crate :: interrupt :: typelevel :: EXTI15_10 ; pub type EXTI15 = crate :: interrupt :: typelevel :: EXTI15_10 ; pub type EXTI3 = crate :: interrupt :: typelevel :: EXTI3 ; pub type EXTI4 = crate :: interrupt :: typelevel :: EXTI4 ; pub type EXTI5 = crate :: interrupt :: typelevel :: EXTI9_5 ; pub type EXTI6 = crate :: interrupt :: typelevel :: EXTI9_5 ; pub type EXTI7 = crate :: interrupt :: typelevel :: EXTI9_5 ; pub type EXTI8 = crate :: interrupt :: typelevel :: EXTI9_5 ; pub type EXTI9 = crate :: interrupt :: typelevel :: EXTI9_5 ; } pub mod FLASH { pub type GLOBAL = crate :: interrupt :: typelevel :: FLASH ; } pub mod GPIOA { } pub mod GPIOB { } pub mod GPIOC { } pub mod GPIOD { } pub mod GPIOE { } pub mod GPIOF { } pub mod GPIOG { } pub mod GPIOH { } pub mod I2C1 { pub type ER = crate :: interrupt :: typelevel :: I2C1_ER ; pub type EV = crate :: interrupt :: typelevel :: I2C1_EV ; } pub mod I2C2 { pub type ER = crate :: interrupt :: typelevel :: I2C2_ER ; pub type EV = crate :: interrupt :: typelevel :: I2C2_EV ; } pub mod I2C3 { pub type ER = crate :: interrupt :: typelevel :: I2C3_ER ; pub type EV = crate :: interrupt :: typelevel :: I2C3_EV ; } pub mod IWDG { } pub mod OPAMP1 { } pub mod OPAMP2 { } pub mod OPAMP3 { } pub mod OPAMP4 { } pub mod PWR { } pub mod RCC { pub type GLOBAL = crate :: interrupt :: typelevel :: RCC ; } pub mod RTC { pub type ALARM = crate :: interrupt :: typelevel :: RTC_ALARM ; pub type STAMP = crate :: interrupt :: typelevel :: TAMP_STAMP ; pub type TAMP = crate :: interrupt :: typelevel :: TAMP_STAMP ; pub type WKUP = crate :: interrupt :: typelevel :: RTC_WKUP ; } pub mod SPI1 { pub type GLOBAL = crate :: interrupt :: typelevel :: SPI1 ; } pub mod SPI2 { pub type GLOBAL = crate :: interrupt :: typelevel :: SPI2 ; } pub mod SPI3 { pub type GLOBAL = crate :: interrupt :: typelevel :: SPI3 ; } pub mod SYSCFG { } pub mod TIM1 { pub type BRK = crate :: interrupt :: typelevel :: TIM1_BRK_TIM15 ; pub type CC = crate :: interrupt :: typelevel :: TIM1_CC ; pub type COM = crate :: interrupt :: typelevel :: TIM1_TRG_COM_TIM17 ; pub type TRG = crate :: interrupt :: typelevel :: TIM1_TRG_COM_TIM17 ; pub type UP = crate :: interrupt :: typelevel :: TIM1_UP_TIM16 ; } pub mod TIM15 { pub type BRK = crate :: interrupt :: typelevel :: TIM1_BRK_TIM15 ; pub type CC = crate :: interrupt :: typelevel :: TIM1_BRK_TIM15 ; pub type COM = crate :: interrupt :: typelevel :: TIM1_BRK_TIM15 ; pub type TRG = crate :: interrupt :: typelevel :: TIM1_BRK_TIM15 ; pub type UP = crate :: interrupt :: typelevel :: TIM1_BRK_TIM15 ; } pub mod TIM16 { pub type BRK = crate :: interrupt :: typelevel :: TIM1_UP_TIM16 ; pub type CC = crate :: interrupt :: typelevel :: TIM1_UP_TIM16 ; pub type COM = crate :: interrupt :: typelevel :: TIM1_UP_TIM16 ; pub type TRG = crate :: interrupt :: typelevel :: TIM1_UP_TIM16 ; pub type UP = crate :: interrupt :: typelevel :: TIM1_UP_TIM16 ; } pub mod TIM17 { pub type BRK = crate :: interrupt :: typelevel :: TIM1_TRG_COM_TIM17 ; pub type CC = crate :: interrupt :: typelevel :: TIM1_TRG_COM_TIM17 ; pub type COM = crate :: interrupt :: typelevel :: TIM1_TRG_COM_TIM17 ; pub type TRG = crate :: interrupt :: typelevel :: TIM1_TRG_COM_TIM17 ; pub type UP = crate :: interrupt :: typelevel :: TIM1_TRG_COM_TIM17 ; } pub mod TIM2 { pub type BRK = crate :: interrupt :: typelevel :: TIM2 ; pub type CC = crate :: interrupt :: typelevel :: TIM2 ; pub type COM = crate :: interrupt :: typelevel :: TIM2 ; pub type TRG = crate :: interrupt :: typelevel :: TIM2 ; pub type UP = crate :: interrupt :: typelevel :: TIM2 ; } pub mod TIM3 { pub type BRK = crate :: interrupt :: typelevel :: TIM3 ; pub type CC = crate :: interrupt :: typelevel :: TIM3 ; pub type COM = crate :: interrupt :: typelevel :: TIM3 ; pub type TRG = crate :: interrupt :: typelevel :: TIM3 ; pub type UP = crate :: interrupt :: typelevel :: TIM3 ; } pub mod TIM4 { pub type BRK = crate :: interrupt :: typelevel :: TIM4 ; pub type CC = crate :: interrupt :: typelevel :: TIM4 ; pub type COM = crate :: interrupt :: typelevel :: TIM4 ; pub type TRG = crate :: interrupt :: typelevel :: TIM4 ; pub type UP = crate :: interrupt :: typelevel :: TIM4 ; } pub mod TIM6 { pub type BRK = crate :: interrupt :: typelevel :: TIM6_DAC ; pub type CC = crate :: interrupt :: typelevel :: TIM6_DAC ; pub type COM = crate :: interrupt :: typelevel :: TIM6_DAC ; pub type TRG = crate :: interrupt :: typelevel :: TIM6_DAC ; pub type UP = crate :: interrupt :: typelevel :: TIM6_DAC ; } pub mod TIM7 { pub type BRK = crate :: interrupt :: typelevel :: TIM7 ; pub type CC = crate :: interrupt :: typelevel :: TIM7 ; pub type COM = crate :: interrupt :: typelevel :: TIM7 ; pub type TRG = crate :: interrupt :: typelevel :: TIM7 ; pub type UP = crate :: interrupt :: typelevel :: TIM7 ; } pub mod TIM8 { pub type BRK = crate :: interrupt :: typelevel :: TIM8_BRK ; pub type CC = crate :: interrupt :: typelevel :: TIM8_CC ; pub type COM = crate :: interrupt :: typelevel :: TIM8_TRG_COM ; pub type TRG = crate :: interrupt :: typelevel :: TIM8_TRG_COM ; pub type UP = crate :: interrupt :: typelevel :: TIM8_UP ; } pub mod TSC { pub type GLOBAL = crate :: interrupt :: typelevel :: EXTI2_TSC ; } pub mod UART4 { pub type GLOBAL = crate :: interrupt :: typelevel :: UART4 ; } pub mod UART5 { pub type GLOBAL = crate :: interrupt :: typelevel :: UART5 ; } pub mod UID { } pub mod USART1 { pub type GLOBAL = crate :: interrupt :: typelevel :: USART1 ; } pub mod USART2 { pub type GLOBAL = crate :: interrupt :: typelevel :: USART2 ; } pub mod USART3 { pub type GLOBAL = crate :: interrupt :: typelevel :: USART3 ; } pub mod USB { pub type HP = crate :: interrupt :: typelevel :: USB_HP_CAN_TX ; pub type LP = crate :: interrupt :: typelevel :: USB_LP_CAN_RX0 ; pub type WKUP = crate :: interrupt :: typelevel :: USBWAKEUP ; } pub mod USBRAM { } pub mod VREFINTCAL { } pub mod WWDG { pub type GLOBAL = crate :: interrupt :: typelevel :: WWDG ; pub type RST = crate :: interrupt :: typelevel :: WWDG ; } } pub (crate) const DMA_CHANNEL_COUNT : usize = 0usize ; pub (crate) const BDMA_CHANNEL_COUNT : usize = 12usize ; pub (crate) const GPDMA_CHANNEL_COUNT : usize = 0usize ;